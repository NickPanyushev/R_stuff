---
title: "NF-kB sites"
author: "Панюшев Николай"
date: '29 марта 2017 г '
output: html_document
---

## Цель и задачи этого маленького проектика

Я решил подобрать праймеры для контроля чипсековской библиотеки для секвенирования, чтобы контролировать обогащение. Если эксперимент прошел успешно, то в IP сигнал должен быть гораздо сильнее, чем в IP c неспецифическими IgG. 

Chip-seq мы будем проводить на H1299, а на них экспериментов не делалось, к сожалению.

Поэтому я решил взять клеточные линии: A549, SGBS, IMR90, HeLa, HUVEC, MCF7 и отобрать из них самые мощные пики. Итак, посмотрим, что из этого вышло.



```{r libraries import, echo=F, warning=FALSE, message=FALSE}
library(ggplot2)
library(corrplot)
library(tidyr)
library(VennDiagram)
#library(stargazer)
library(data.table)
```

## Импорт данных

Сделаем функцию, которая будет нам данные считывать и сразу фильтровать

Добавить сюда штуку, которая будет levels от хромосом переименовывать и в правильном порядке расставлять

```{r import&filtering function}
read.narrowpeak <- function(filename, filtering=TRUE){
  raw_peaks <-  read.table(filename, header = F, sep = "\t")
  names(raw_peaks) <- c("Chromosome", "Start", "Stop", "Peak_name",
                        "display_int", "dot",
                        "fold_change", "p-value", "q-value",
                        "summit_position_from_start")
  
  if (filtering == TRUE){
    #Выбросим неинформативные колонки
    raw_peaks$dot = raw_peaks$display_int <- NULL
    #удаляем хромосомы, которые странно называются
    raw_peaks <- raw_peaks[grep(pattern = "chr\\w\\d?", raw_peaks$Chromosome), ]
    #Митохондриалку тоже выбросим, там не должно быть ТФ
    raw_peaks <- raw_peaks[!raw_peaks$Chromosome == "chrM",]
    #Переставим имена хромосом в нормальном порядке
    raw_peaks$Chromosome <- factor(raw_peaks$Chromosome, 
                                   levels =c("chr1","chr2","chr3","chr4","chr5",
                                    "chr6","chr7","chr8","chr9","chr10",
                                    "chr11", "chr12", "chr13", "chr14", "chr15",
                                    "chr16", "chr17", "chr18", "chr19", "chr20",
                                    "chr21", "chr22", "chrX", "chrY"))
    droplevels(raw_peaks)
    raw_peaks <- as.data.table(raw_peaks)
    }
  return(raw_peaks)
}
```

Теперь считаем файлы с пиками с помощью этой чудодейственной функции

```{r file read, warning=FALSE}

A549_peaks <- read.narrowpeak("MACS2_p65_peaks/A549_TNF_vs_bg_peaks.narrowPeak")
HeLa_peaks <- read.narrowpeak("MACS2_p65_peaks/HELA_TNFvsDMSO_peaks.narrowPeak")
HUVEC_peaks <- read.narrowpeak("MACS2_p65_peaks/HUVEC_TNFvsASIS_peaks.narrowPeak")
IMR90_peaks <- read.narrowpeak("MACS2_p65_peaks/IMR90_TNFvsASIS_peaks.narrowPeak")
MCF7_peaks <- read.narrowpeak("MACS2_p65_peaks/MCF7_TNFvsVeh_peaks.narrowPeak")
SGBS_peaks <- read.narrowpeak("MACS2_p65_peaks/SGBS_TNFvsVeh_peaks.narrowPeak")
```

Итак, количество пиков по линиям

* A549 - `r nrow(A549_peaks)` 
* HeLa - `r nrow(HeLa_peaks)` - очень мало! 
* HUVEC - `r nrow(HUVEC_peaks)` 
* IMR90 - `r nrow(IMR90_peaks)` 
* MCF7 - `r nrow(MCF7_peaks)` - очень мало! 
* SGBS - `r nrow(SGBS_peaks)` 

Скорее всего, либо ошибка при пик-коллинге, или не прошла активация TNF. 
На вопрос, где ошибка, нам помогут ответить модельки, которые нам выдавал MACS2.

Картинка показывает насколько пики на + и - цепи смещены относительно друг друга. Если все сработало верно, то должно быть хорошее бимодальное распределение. Величина сдвига должна быть близка к размеру нуклеосомы. 

Клеточная линия  | Величина сдвига | Распределение ридов
------------- | ------------- | -------------
A549  | 261 п.н. | `r knitr::include_graphics("Peak_pics/A549_TNF_vs_bg_model-0.png", dpi = 200)`  
HUVEC | 115 п.н. | `r knitr::include_graphics("Peak_pics/HUVEC_TNFvsASIS_model-0.png", dpi = 200)`
IMR90 | 141 п.н. | `r knitr::include_graphics("Peak_pics/IMR90_TNFvsASIS_model-0.png", dpi = 200)`  
SGBS | 161 п.н.|  `r knitr::include_graphics("Peak_pics/SGBS_TNFvsVeh_model-0.png", dpi = 200)`  
HeLa | 34, 96, 500 п.н. |`r knitr::include_graphics("Peak_pics/HELA_TNFvsDMSO_model-0.png", dpi = 200)`  
MCF7 | 148 п.н. | `r knitr::include_graphics("Peak_pics/MCF7_TNFvsVeh_model-0.png", dpi = 200)`  

Итак, видим, что в HeLa какие-то проблемы с секвенированием произошли, и/или с экспериментом, поэтому от их использования придется отказаться.  
MCF7 - выглядит лучше, чем HeLa, но с ними тоже не все хорошо, откажемся от них  
A549 - Вызывает опасения, не очень красивое распределение и великоват сдвиг, но мы все равно попробуем с ними поработать.

Cложим все пики вместе, чтобы не возиться с 4мя датасетами, а сразу их объединить.

```{r merge peaks}
A549_peaks$Cell_line <- "A549"
HUVEC_peaks$Cell_line <- "HUVEC"
IMR90_peaks$Cell_line <- "IMR90"
SGBS_peaks$Cell_line <- "SGBS"
all_peaks <- rbindlist(list(A549_peaks, HUVEC_peaks, IMR90_peaks, SGBS_peaks))
```

Теперь проанализируем fold_change, он должен давать нормальное распределение, что было бы вполне логично, и оно должно быть примерно одинаковым в разных линиях

```{r fold_change analysis, echo=FALSE}
ggplot(all_peaks, aes(fold_change, ..count.., fill = Chromosome))+
  geom_density(aes(fill=Chromosome), alpha = 0.5) +
  labs(title = "Fold change peak distribution",
       x = "Fold change",
       y = "Peak number")+
  theme_bw()+
  facet_wrap(~ Cell_line)
```

Прикольно, что у SGBS пиков аж в 3 раза больше, надо это взять на заметку!
Интересно, почему? 
Видимо, дело либо в клетках, либо сделано слишком много ридов  
Посмотрим на цифры:

```{r, echo=F}
attach(all_peaks)
chrom_peaks <- aggregate(all_peaks$Peak_name, by=list(Chromosome, Cell_line), FUN=length)
detach(all_peaks)
names(chrom_peaks) <- c("Chromosome", "Cell_line", "Peak_number")

chroms <- data.frame(chrom_peaks[chrom_peaks$Cell_line == "A549", c(1,3)])
names(chroms) <- c("Chromosome", "A549")
chroms$HUVEC <- chrom_peaks[chrom_peaks$Cell_line == "HUVEC", 3]
chroms[24,1] <- "chrY"
chroms$IMR90 <- chrom_peaks[chrom_peaks$Cell_line == "IMR90", 3]
chroms$SGBS <- chrom_peaks[chrom_peaks$Cell_line == "SGBS", 3]
print(chroms)

```
Видно, что A549 и HUVEC очень похожи по количеству пиков.

Построим для всех этих пиков гистограммку распределения пиков по хромосомам

И еще заменим подписи снизу гистограммы на номер хромосомы сверху, и уберем расцветку

И добавим туда линию, которая нам покажет, как уменьшаются хромосомы по мере возрастания их номера.
!!!(Не сделано пока что)!!!

```{r, echo=FALSE, warning=FALSE}
ggplot(all_peaks, aes(Chromosome, fill = Chromosome))+
  geom_histogram(aes(fill=Chromosome), alpha = 0.5, stat = "count") +
  labs(title = "Peak location distribution",
       x = "Genome location",
       y = "Peak number")+
  theme_bw()+
  facet_wrap(~ Cell_line)
```

Ну что, выглядит вполне красиво и логично - у нас есть пики, которые во всех линиях распределены примерно одинаково, значит, с данными все относительно хорошо.

Чтобы избавиться от шума,бинаризуем пики окошком в 50 п.о., напишем для этого небольшую функцию.

```{r binarization_function}
bin.peaks <- function(dataframe, window_size = 50, append = TRUE)
{
  #Эта функция выдает номера бинов в диапазоне [START, STOP]
  fun <- function(Start, Stop)
  { 
    bin_start <- floor(Start/window_size)*window_size
    bin_stop <- ceiling(Stop/window_size)*window_size - window_size
    positions <- seq(bin_start, bin_stop, by = window_size)
  return(positions)
  }
  
  if (append == TRUE){
    dataframe$Peak_Bins <- mapply(fun, dataframe$Start, dataframe$Stop)
    return(dataframe)
  }else{
    bin_vector <- unlist(mapply(fun, dataframe$Start, dataframe$Stop))
    bin_vector <- sort(bin_vector)
    return(bin_vector)
  }
}
```

Теперь бинаризуем, и добавим для этого столбец Peak_Bins
```{r binarization}
all_peaks <- bin.peaks(all_peaks, window_size = 50)

#Выделим для каждого бина отдельную строку, чтобы было удобнее. Для этого возьмем функцию unnest из пакетика tidyr
all_bins <- unnest(all_peaks, Peak_Bins)
all_bins <- as.data.table(all_bins)
```

Наступает время корреляций! 
Для начала посмотрим на корреляции всех пиков между различными клеточными линиями, убрав, разумеется, Y-хромосому, иначе сравнивать некорректно, так как у нас есть женские линии.
При недостатке пиков будем добавлять нули, чтобы не обрезать информативные пики в более длинных датасетах 


```{r}
A549 <- all_bins[all_bins$Cell_line =="A549" & all_bins$Chromosome !="chrY", "Peak_Bins" ]
HUVEC <- all_bins[all_bins$Cell_line =="HUVEC" & all_bins$Chromosome !="chrY", "Peak_Bins" ]
IMR90 <- all_bins[all_bins$Cell_line =="IMR90" & all_bins$Chromosome !="chrY", "Peak_Bins" ]
SGBS <- all_bins[all_bins$Cell_line =="SGBS" & all_bins$Chromosome !="chrY", "Peak_Bins" ]
cor_table <- cbind("A549" = A549,
                   "HUVEC" = HUVEC,
                   "IMR90" = IMR90,
                   "SGBS" = SGBS)

M <- cor(cor_table, method = "pearson")
#cor.test (HUVEC, sample(A549, length(HUVEC)))
corrplot(M, method = "number", type = "lower")
remove(M)
```

Теперь построим корреляционную матрицу между не самыми мощными пиками fold_change =< 15. Что я думаю, что они должны лучше коррелировать

```{r}
A549 <- all_bins[all_bins$Cell_line =="A549" & all_bins$Chromosome !="chrY" 
                 & all_bins$fold_change <= 15, "Peak_Bins" ]

HUVEC <- all_bins[all_bins$Cell_line =="HUVEC" & all_bins$Chromosome !="chrY" 
                  & all_bins$fold_change <= 15, "Peak_Bins" ]
IMR90 <- all_bins[all_bins$Cell_line =="IMR90" & all_bins$Chromosome !="chrY"
                  & all_bins$fold_change <= 15, "Peak_Bins" ]
SGBS <- all_bins[all_bins$Cell_line =="SGBS" & all_bins$Chromosome !="chrY"
                 & all_bins$fold_change <= 15, "Peak_Bins" ]

cor_table <- cbind("A549" = A549,
                   "HUVEC" = HUVEC,
                   "IMR90" = IMR90,
                   "SGBS" = SGBS)

M <- cor(cor_table, method = "pearson")
corrplot(M, method = "number", type = "lower")
remove(M)
```

И что, видим то же самое, никаких принципиальных изменений

Теперь попробуем с самыми мощными

```{r}
A549 <- all_bins[all_bins$Cell_line =="A549" & all_bins$Chromosome !="chrY" 
                 & all_bins$fold_change > 15, "Peak_Bins" ]

HUVEC <- all_bins[all_bins$Cell_line =="HUVEC" & all_bins$Chromosome !="chrY" 
                  & all_bins$fold_change > 15, "Peak_Bins" ]
IMR90 <- all_bins[all_bins$Cell_line =="IMR90" & all_bins$Chromosome !="chrY"
                  & all_bins$fold_change > 15, "Peak_Bins" ]
SGBS <- all_bins[all_bins$Cell_line =="SGBS" & all_bins$Chromosome !="chrY"
                 & all_bins$fold_change > 15, "Peak_Bins" ]

cor_table <- cbind("A549" = A549,
                   "HUVEC" = HUVEC,
                   "IMR90" = IMR90,
                   "SGBS" = SGBS)

M <- cor(cor_table, method = "pearson")
corrplot(M, method = "number", type = "lower")
remove(M)
```

Ну вообще совсем ничего, то есть корреляцию делают только маленькие пики. 
А теперь построим картинку с диаграммой Венна, чтобы посмотреть, какие пики у нас везде есть. 

```{r}

#Сделаем список, VennDiagram принимает только списки

bins_plot <- list(A549 = all_bins[all_bins$Cell_line =="A549", "Peak_Bins"],
                  HUVEC = all_bins[all_bins$Cell_line =="HUVEC", "Peak_Bins"],
                  IMR90 = all_bins[all_bins$Cell_line =="IMR90", "Peak_Bins"],
                  SGBS = all_bins[all_bins$Cell_line =="SGBS", "Peak_Bins"])

#bin_plot <- venn.diagram(bins_plot, NULL, cex = 2, cat.fontface=4, 
 #                         category.names=c("A549", "HUVEC", "IMR90", "SGBS"), 
  #                        main="Пересечение пиков")

bin_plot <- venn.diagram(bins_plot, NULL,
  col = "transparent",
	fill = c("cornflowerblue", "green", "yellow", "darkorchid1"),
	alpha = 0.50,
	label.col = c("orange", "white", "darkorchid4", "white", 
	"white", "white", "white", "white", "darkblue", "white", 
	"white", "white", "white", "darkgreen", "white"),
	cex = 1.5,
	fontfamily = "serif",
	fontface = "bold",
	cat.col = c("darkblue", "darkgreen", "orange", "darkorchid4"),
	cat.cex = 1.5,
	cat.pos = 0,
	cat.dist = 0.07,
	cat.fontfamily = "serif",
	rotation.degree = 270,
	margin = 0.2,
  category.names=c("A549", "HUVEC", "IMR90", "SGBS"), 
                          main="Пересечение пиков")

grid.draw(bin_plot)

```

```{r}
common_bins_1 <- fintersect(all_bins[all_bins$Cell_line =="A549", "Peak_Bins"], 
                  all_bins[all_bins$Cell_line =="HUVEC", "Peak_Bins"])
                  
common_bins_2 <-  fintersect(all_bins[all_bins$Cell_line =="IMR90", "Peak_Bins"],
                  all_bins[all_bins$Cell_line =="SGBS", "Peak_Bins"])

common_bins <- fintersect(common_bins_1, common_bins_2)
common_bins <- common_bins$Peak_Bins

remove(common_bins_1,common_bins_2)
```

Уху! Что же мы видим, у нас есть `r length(common_bins)`  общих бинов, которые есть везде, во всех клеточных линиях. 
Отберем их для начала. 

Ну-ка, посмотрим на них, построим диаграммку их распределения по геному. 

```{r common_peaks analysis, echo=FALSE, eval=F}

merged_bins <- all_bins[all_bins$Peak_Bins %in% common_bins, ]

#Посчитали длину каждого пересечения
peak_lengths <- aggregate(merged_bins$Peak_Bins,
                          by = list(merged_bins$Peak_name, merged_bins$Cell_line),
                          FUN = function(x) max(x)-min(x)+50)

names(peak_lengths) <- c("Peak_name", "Cell_line", "Length")


peak_lengths$Position <- aggregate(merged_bins$Peak_Bins,
                          by = list(merged_bins$Peak_name),
                          FUN = mean)[,2]

peak_lengths$Fold_change <- aggregate(merged_bins$fold_change,
                          by = list(merged_bins$Peak_name),
                          FUN = function(x) x[1])[,2]

#сделаем новый датафрейм, в котором у нас будут записаны общие пики, а потом запишем его в .bed файл

common_peaks <- aggregate(merged_bins$Peak_Bins,
                          by = list(merged_bins$Peak_name, merged_bins$Cell_line),
                          FUN = min)

names(common_peaks) <- c("Peak_name", "Cell_line", "Start")

common_peaks$Stop <- aggregate(merged_bins$Peak_Bins,
                          by = list(merged_bins$Peak_name),
                          FUN = function(x) max(x)+50)[,2]

common_peaks$Chromosome <- aggregate(merged_bins$Chromosome,
                          by = list(merged_bins$Peak_name),
                          FUN = function(x) x[1])[,2]

common_peaks$Fold_change <- aggregate(merged_bins$fold_change,
                          by = list(merged_bins$Peak_name),
                          FUN = function(x) x[1])[,2]

common_peaks$'p-value' <- aggregate(merged_bins$`p-value`,
                          by = list(merged_bins$Peak_name),
                          FUN = function(x) x[1])[,2]

common_peaks$'q-value' <- aggregate(merged_bins$`q-value`,
                          by = list(merged_bins$Peak_name),
                          FUN = function(x) x[1])[,2]

#Переставим в правильном порядке столбцы, чтобы bedtools съел

common_peaks <- common_peaks[,c("Chromosome", "Start", "Stop", "Peak_name", 
                             "Fold_change", "p-value", "q-value", "Cell_line")]
# Запишем в файл

fwrite(common_peaks, "Annotation/peaks.bed", sep = "\t", col.names = FALSE)


ggplot(peak_lengths, aes(x = Position, y = Fold_change))+
 geom_point(colour = "blue", aes(size = Length), alpha = 0.5) +
  labs(title = "Fold change peak distribution",
       x = "Location",
       y = "Fold_change")+
  theme_bw()+
  facet_wrap(~ Cell_line)

ggplot(peak_lengths[peak_lengths$Fold_change > 25,], 
       aes(x = Position, y = Fold_change))+
 geom_point(colour = "blue", aes(size = Length), alpha = 0.5) +
  labs(title = "Fold change peak distribution",
       x = "Location",
       y = "Fold_change")+
  theme_bw()+
  facet_wrap(~ Cell_line)

ggplot(peak_lengths, aes(x = Cell_line, y = Fold_change))+
 geom_boxplot() +
  labs(title = "Fold change peak distribution",
              y = "Fold change")+
  theme_bw()

#Выбросим положения пиков и их длину, они нам больше не нужны.
remove(peak_lengths)
```

Что мы видим: 
Общие для этих клеточных линий пики примерно одинаковой высоты, только у нас есть SGBS, где пики несколько выше. 

Однако, между ними везде достоверная разница.

Теперь наконец-то притянем аннотацию

Или наоборот, притянем аннотацию ручками из GFF-файла и сохраним ее в отдельном файле
Для этих операций используем library(data.table)

```{r Получение аннотации}
#Uncomment if you want to make new annotaton from the GFF3
#raw_gff <- fread( "sed '/#/d' /home/nickolay/Human_genome/Genprime_v24/gencode.v24.annotation.gff3")
#raw_gff[,c(2,6,8)] <- NULL

#raw_gff$V9 <- strsplit(raw_gff$V9, ";")
#raw_gff$ID <- sapply(raw_gff$V9,function(x) x[1])
#raw_gff$ID <- gsub("ID=\\w*:?E", "E", raw_gff$ID)

#annotation_v24 <- raw_gff[,c(1:5, 7)]
#rownames(annotation_v24) <- NULL
#annotation_v24$V1 <- NULL
#names(annotation_v24) <- c("Chromosome", "Type", "Start", "Stop", "Strand", "Ensemble_ID")

#fwrite(annotation_v24, file = "Annotation/Gencode_v24.bed", sep = "\t")

annotation_v24 <- fread("Annotation/Gencode_v24.bed")

#Теперь вытащим только транскрипты
transcripts <- subset(annotation_v24, annotation_v24$Type == "transcript")
transcripts$Type <- NULL
fwrite(transcripts, "Annotation/transcripts.bed", sep = "\t", col.names = FALSE)
```

Не будем изобретать велосипед, а сделаем скрипт, который с помощью bedtools найдет нам ближайшие гены.

```{r, engine= 'bash'}
cd ~/R_stuff/NF-kB_sites/Annotation
#Отсортируем файл с транскриптами и с пиками
sortBed -i transcripts.bed > sorted_transcripts.bed
sortBed -i peaks.bed > sorted_peaks.bed

#А теперь пошли фичи искать
closestBed -D b -k 2 -a sorted_peaks.bed -b sorted_transcripts.bed > closest_transcripts.bed
```

Окей, нашли ближайшие транскрипты, отфильруем их

```{r}
features <- fread("Annotation/closest_transcripts.bed")
names(features) <- c("Chromosome", "peak_Start", "peak_Stop", "Peak_name", 
                             "Fold_change", "p-value", "q-value", "Cell_line",
                     "Chr", "transcript_Start", "transcript_Stop", "Strand", 
                     "Ensemble_ID", "distance")
features$Chr <- NULL
# Убрали пики, которые лежат очень далеко в пустоте, т.е. от них до гена более 3000 нуклеотидов

features <- subset(features, features$distance<3000 & features$distance > - 3000)

#Удалим хвостики у названий транскриптов
features$Ensemble_ID <- gsub("\\.\\d+", "", features$Ensemble_ID)
```

Теперь попробуем проаннотировать гены по GO

```{r common peaks annotation}
library(biomaRt)

# define biomart object
attr <- listAttributes(mart)
mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")

# query biomart
BM_out <- getBM(attributes = c("ensembl_transcript_id", "uniprotswissprot",
                                "hgnc_symbol", "transcript_biotype",
                                "go_id", "name_1006", 
                                "namespace_1003"),
                 filters = "ensembl_transcript_id",
                values = features$Ensemble_ID, 
                mart = mart,
                uniqueRows = TRUE)
```
Теперь, когда у нас есть огромная аннотация, надо ее расчистить

```{r}
#Удалим неинформативные GO
BM_out <- BM_out[BM_out$name_1006 != "molecular_function" &
                  BM_out$name_1006 != "cellular_component" &
                   BM_out$name_1006 != "biological_process" ,]

#Теперь сагрегируем по namespace
GO_data <- data.table()
GO_data <- aggregate(BM_out$name_1006,
                          by = list(BM_out$namespace_1003, BM_out$ensembl_transcript_id),
                          FUN = as.vector)




```






