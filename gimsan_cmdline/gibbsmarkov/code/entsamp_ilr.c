#include "entsamp_ilr.h"

/**
* Main engine of GibbsIlr
* 
* return: 
*   returns the run-node of the best run
**/
RunNode* runGibbsIlr(GibbsIlr *gilr) {
	Gibbs *gibbs = gilr->gibbs;
	
	int r = 0;

	while(1) {
		//initspan and maxspan are the same in GibbsILR 
		int initspan = gibbs->span;
		int maxspan = gibbs->span;
		RunNode *rnode = createRunNode(r, gibbs->data, initspan, maxspan); 

		//new set of positions (sites) by random
		setRandomSites(rnode->sites, initspan, gibbs->data, gibbs->zoops);
		runIters(rnode, initspan, gibbs);
		
		//add to the list of gibbs->runset
		if(gibbs->runset->len > 0) {
			rnode->next = gibbs->runset->head;
		}
		gibbs->runset->head = rnode;
		gibbs->runset->len++;

		//Before EM verbose info
		if(DEBUG1) {
			fprintf(stderr, "runid: %03d\n", rnode->runId);
			fprintf(stderr,"Before EM:\n");
			printCountmat(stderr, rnode->countmat);
		}

		//copy the gap positions
		copyProfile(rnode->pswm, rnode->countmat); 

		//compute frequency weight matrix through normalization (since there may be pseudocount)
		for(int i = 0; i < rnode->pswm->span; i++) {
			double sum = 0.0;
			for(int j = 0; j < NUMALPHAS; j++) {
				sum += rnode->pswm->mat[i][j];
			}
			for(int j = 0; j < NUMALPHAS; j++) {
				rnode->pswm->mat[i][j] /= sum;
			}
		}

		if(gilr->emStep > 0) {
			if(gibbs->isZoopsMode) {
				fprintf(stderr, "EM is currently not implemented for ZOOPS.\n");
				exit(1);
			}

			//adding pseudoweight for EM
			for(int i = 0; i < rnode->pswm->span; i++) {
				//naive pseudocount
				double sum = 0.0;
				const double threshold = 0.05;
				for(int j = 0; j < NUMALPHAS; j++) {
					if(rnode->pswm->mat[i][j] < threshold) {
						rnode->pswm->mat[i][j] = threshold;
					}
					sum += rnode->pswm->mat[i][j];
				}

				//normalize
				for(int j = 0; j < NUMALPHAS; j++) {
					rnode->pswm->mat[i][j] /= sum;
				}
			}

			//EM
			runEmSteps(gibbs->markov, rnode->pswm, gibbs->data, gilr->emStep, true); 
		}
		findBestSitesByAvgLR(gibbs->markov, rnode->pswm, rnode->sites, gibbs->data); 
		updateCountmatFromSites(rnode->countmat, rnode->sites, gibbs->data); 

		if(gilr->metric == CLR) {
			//new for markov
			rnode->score = computeEntropy(gibbs->markov, gibbs->data, gibbs->zoops, rnode->sites, rnode->countmat->span); //new for markov
		}
		else {
			//new for markov
			//ilr from PWM
			rnode->score = computeIlr(gibbs->markov, gibbs->data, rnode->pswm->mat, rnode->countmat->span);
		}

		//After EM verbose info
		if(DEBUG1) {
			fprintf(stderr,"After EM:\n");
			for(int i = 0; i < gibbs->data->numseqs; i++) {
				fprintf(stderr, "sites[%2d] %4d\n", i, rnode->sites[i]);
			}
			fprintf(stderr,"Score generated by sites: %.2lf\n", rnode->score);
			printCountmat(stderr, rnode->countmat);
			fprintf(stderr,"\n");
		}

		//The following enforces the two stopping criterion
		r++;
		if(gibbs->runThrshldTyp == NUMRUNS && r >= gibbs->numruns) {
			break;
		}

		if(gibbs->runThrshldTyp == CPUTIME) {
			double elapsed = ((double) ( clock() - gibbs->cpuClockStart)) / CLOCKS_PER_SEC;

			//give an extra couple of seconds for errands
			if( elapsed + 5.00 > gibbs->cpuSecThrshld) { 
				break;
			}
		}

	}

	if(DEBUG0) {
		if(gibbs->runThrshldTyp == NUMRUNS && gibbs->runset->len != gibbs->numruns) {
			fprintf(stderr, "Error: inconsistent number of runs at runGibbsPV\n");
			exit(1);
		}
	}

	RunNode *node; 
	RunNode *bestnode = NULL;
	double maxval = -DBL_MAX; //favors largest values of ILR or entropy
	for(node = gibbs->runset->head; node!= NULL; node = node->next) {
		if(maxval < node->score) {
			maxval = node->score;
			bestnode = node;
		}
	}

	if(DEBUG1) {
		fprintf(stderr, "\nBest among all runs:\n");
		fprintf(stderr, "runid: %03d\n", bestnode->runId);
		printCountmat(stderr, bestnode->countmat);
	}

	return bestnode;
}
void nilGibbsIlr(GibbsIlr *gilr ) {
	nilGibbs(gilr->gibbs);
	free(gilr);
}

